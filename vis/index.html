<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Tree Example</title>

    <style>

     .node {
       cursor: pointer;
     }

     .node circle {
       stroke: steelblue;
       stroke-width: 3px;
     }

     .node text {
       font: 12px sans-serif;
     }

     .link {
       fill: none;
       stroke: #ccc;
       stroke-width: 2px;
     }
     
    </style>

  </head>

  <body>

    <!-- load the d3.js library -->	
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script> -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    
    <script>

     // colors
     var pathColor = "steelblue";
     //     var forwardPathColor = "#709176";
     //     var backwardPathColor = "#ad343e";
     var originalLinkColor = "#ccc";
     var correctPredColor = "#709176";
     var incorrectPredColor = "#ad343e";
     var baseNodeColor = "#fff";
     var leafColor = "#cfdbd5";

     // set the dimensions and margins of the diagram
     var margin = {top: 20, right: 90, bottom: 30, left: 90},
         width = 1200 - margin.left - margin.right,
         height = 500 - margin.top - margin.bottom;

     // declares a tree layout and assigns the size
     var treemap = d3.tree()
                     .size([height, width]);

     // use data to make visualization

     function showTree(error, stats, treeData, wnidToClass, indexToWnid) {
       if (error) throw error;
       console.log(treeData);

       //  assigns the data to a hierarchy using parent-child relationships
       var nodes = d3.hierarchy(treeData, function(d) {
         return d.children;
       });

       // maps the node data to the tree layout
       nodes = treemap(nodes);

       // append the svg object to the body of the page
       // appends a 'group' element to 'svg'
       // moves the 'group' element to the top left margin
       var svg = d3.select("body").append("svg")
                   .attr("width", width + margin.left + margin.right)
                   .attr("height", height + margin.top + margin.bottom),
           g = svg.append("g")
                  .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

       // adds the links between the nodes
       var link = g.selectAll(".link")
                   .data( nodes.descendants().slice(1))
                   .enter().append("path")
                   .attr("class", function (d) {
                     return "link originalLink " + d.data.name})
                   .attr("d", function(d) {
                     return "M" + d.y + "," + d.x
                          + "C" + (d.y + d.parent.y) / 2 + "," + d.x
                          + " " + (d.y + d.parent.y) / 2 + "," + d.parent.x
                          + " " + d.parent.y + "," + d.parent.x;
                   });

       // adds each node as a group
       var node = g.selectAll(".node")
                   .data(nodes.descendants())
                   .enter().append("g")
                   .attr("class", function(d) {
                     return "node" +  (d.children ? " node--internal" : " node--leaf")
                          + " node--" + d.data.name})
                   .attr("transform", function(d) {
                     return "translate(" + d.y + "," + d.x + ")"; });

       // adds the circle to the node
       node.append("circle")
           .attr("r", 10)
           .style("fill", function (d) {
             return d.data.leaf == "True" ? leafColor : baseNodeColor;
           });

       // adds the text to the node
       node.append("text")
           .attr("dy", ".35em")
           .attr("x", function(d) { return d.children ? -13 : 13; })
           .style("text-anchor", function(d) {
             return d.children ? "end" : "start"; })
           .text(function(d) { return d.data.leaf == "True" ? wnidToClass[d.data.name] : d.data.name; });


       var index = 52; // image index, can change later
       var stat = data[index]
       console.log(stat["path"])

       var backtrackEnd = null;
       var backtracking = false;

       // check if backtracking will start from root
       if (stat["path"].lastIndexOf(stat["path"][0]) != 0) {
         backtrackEnd = stat["path"].lastIndexOf(stat["path"][0]);
         backtracking = true;
       }

       for (var i=1; i < stat["path"].length; i++) {
         var currNode = stat["path"][i]
         var link = g.select("." + currNode)

         if (backtracking && backtrackEnd == i) {
           backtracking = false;
         }

         if (backtracking) {
           link.style("stroke", pathColor)
               .style("stroke-dasharray", ("3,3"))
         } else {
           link.style("stroke", pathColor);

           // check if need to start backtracking
           if (stat["path"].lastIndexOf(currNode) != i) {
             backtracking = true;
             backtrackEnd = stat["path"].lastIndexOf(currNode);
           }
         }

         if (i == stat["path"].length - 1) {

           // color nodes according to predictions
           node.selectAll("circle")
               .style("fill", function(d) {
                 console.log(d);

                 if (d.data.name == currNode && stat["correct"] == "TRUE") {return correctPredColor}
                 if (d.data.name == currNode && stat["correct"] == "FALSE") {return incorrectPredColor}
                 else if (d.data.name == indexToWnid[Number(stat["target index"])]) {                  console.log(stat["target index"]); console.log(wnidToClass[d.data.name]);  return correctPredColor}
                 else {return baseNodeColor}
               });

         }
         console.log(wnidToClass);
         console.log(Number(stat["target index"]));
         console.log(indexToWnid[Number(stat["target index"])]);
         console.log(wnidToClass[indexToWnid[Number(stat["target index"])]]);

       }

       //resetLink(index);

       function resetLink(index) {
         var stat = data[index];
         for (var i=1; i < stat["path"].length; i++) {
           var link = g.select("." + stat["path"][i])
                       .style("stroke", originalLinkColor)

         }
       };


     }
     //   });


           var data = {};
           var parseTsv = function(row){
             data[Number(row["image index"])] = {
               "predicted index": Number(row["predicted index"]),
               "target index": Number(row["target index"]),
               "correct": row["correct"],
               "path": row["path"].match(/(n\d+)+/g),
               "probs": row["path probability"].match(/(\d\.\d*)+/g),
               "path length": Number(row["path length"])
             }
           };


           var classes = {}; // mapping from wnid to human interpretable label
           var parseImagenetClassIndex = function(classIndex) {
             for (key in classIndex) {
               classes[classIndex[key][0]] = classIndex[key][1]
             };
           };

           d3.queue()
             .defer(d3.tsv, "cifar10stats.tsv", parseTsv)
             .defer(d3.json, "new_cifar10_d3.json")
             .defer(d3.json, "cifar10_class_index.json")
             .defer(d3.json, "cifar10_index_to_wnid.json")
             .await(showTree);

    </script>
  </body>


</html>
